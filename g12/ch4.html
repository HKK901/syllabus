<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
            .tble {
              width: 100%;
              border-collapse: collapse;
              font-family: Poppins, Arial, sans-serif;
              margin-top: 1rem;
            }

            .tble thead tr {
              border-bottom: 2px solid #a3d977;
              background-color: transparent;
            }

            .tble th,
            .tble td {
              padding: 12px 16px;
              text-align: left;
              color: #e0e0e0;
            }

            .tble tbody tr:nth-child(odd) {
              background-color: #141414;
            }

            .tble tbody tr:nth-child(even) {
              background-color: #1e1e1e;
            }

  </style>
  <title>Chapter 4: C-Programming</title>
  <link rel="stylesheet" href="../style.css" />
  <link rel="stylesheet" />
</head>

<body>
  <div class="sidebar">
    <a href="../index.html" class="nav-button">Home</a>
    <a href="ch1.html" class="nav-button">DBMS</a>
    <!-- <a href="ch2.html" class="nav-button">Chapter 2</a>
    <a href="ch3.html" class="nav-button">Chapter 3</a> -->
    <a href="ch4.html" class="nav-button active">C-Programming</a>
    <!-- <a href="ch5.html" class="nav-button">Chapter 5</a>
    <a href="ch6.html" class="nav-button">Chapter 6</a>
    <a href="ch7.html" class="nav-button">Chapter 7</a>
    <a href="ch8.html" class="nav-button">Chapter 8</a> -->
  </div>

  <div class="content" id="top">
    <h1 id="top">Chapter 4: C-Programming</h1>
    <div class="section-links">
      <a href="#notes">Notes</a>
      <a href="#questions">Questions and Answers</a>
      <a href="#neb-ques">Past NEB Questions</a>
    </div>

    <div class="section" id="notes">
      <h2>Introduction to Function</h2>
      <div class="section">
      <h2>1. Working with a Function</h2>

      <h3>a. Define Function</h3>
      <p>
        A function is a block of code that performs a specific task. In C, functions help modularize programs and make code reusable and easier to maintain.
      </p>

      <h3>b. Syntax of Functions</h3>
      <pre><code>
return_type function_name(parameters)
{
    // body of the function
}
      </code></pre>

      <h3>c. Types of Functions</h3>
      <ul>
        <li><strong>Library Functions:</strong> Predefined functions provided by C libraries (e.g., printf(), scanf()).</li>
        <li><strong>User Defined Functions:</strong> Functions created by the programmer to perform custom tasks.</li>
      </ul>

      <h3>d. Components of Function</h3>
      <ul>
        <li><strong>Function Prototype:</strong> Declaration of a function before its use.</li>
        <li><strong>Function Call:</strong> Statement that invokes the function.</li>
        <li><strong>Function Definition:</strong> Body of the function where actual statements are written.</li>
        <li><strong>Return Type:</strong> Data type of value returned by the function.</li>
      </ul>
    </div>

    <div class="section">
      <h2>2. Categories of Function with Examples</h2>

      <h3>i. Function with Return Type but No Arguments</h3>
      <pre><code>
int getNumber()
{
    return 10;
}
      </code></pre>

      <h3>ii. Function with Return Type with Arguments</h3>
      <pre><code>
int add(int a, int b)
{
    return a + b;
}
      </code></pre>

      <h3>iii. Function with No Return Type and No Arguments</h3>
      <pre><code>
void display()
{
    printf("Hello World");
}
      </code></pre>

      <h3>iv. Function with No Return Type but with Arguments</h3>
      <pre><code>
void printNumber(int n)
{
    printf("Number is %d", n);
}
      </code></pre>
    </div>

    <div class="section">
    <h2>3. Storage Classes</h2>
    <ul>
        <li>
        <strong>Automatic:</strong> Default storage class for local variables.
        <pre><code>
    void demo()
    {
        int x = 10; // automatic by default
        printf("%d", x);
    }
        </code></pre>
        </li>

        <li>
        <strong>External:</strong> Variables declared outside all functions and accessible globally.
        <pre><code>
    #include &lt;stdio.h&gt;

    int globalVar = 5; // external

    void show()
    {
        printf("%d", globalVar);
    }
        </code></pre>
        </li>

        <li>
        <strong>Register:</strong> Variables stored in CPU registers for faster access.
        <pre><code>
    void fastAccess()
    {
        register int i;
        for(i = 0; i < 10; i++)
            printf("%d ", i);
    }
        </code></pre>
        </li>

        <li>
        <strong>Static:</strong> Variables that retain their value between function calls.
        <pre><code>
    void counter()
    {
        static int count = 0;
        count++;
        printf("Count = %d\n", count);
    }
        </code></pre>
        </li>
    </ul>
    </div>


    <div class="section">
      <h2>4. Recursive Function with Syntax and Example</h2>
      <p>A recursive function calls itself to solve smaller subproblems.</p>
      <p><strong>Syntax:</strong></p>
      <pre><code>
return_type function_name(parameters)
{
    if(condition)
        return result;
    else
        return function_name(updated_parameters);
}
      </code></pre>
      <p><strong>Example 1: Factorial</strong></p>
      <pre><code>
#include &lt;stdio.h&gt;
int fact(int);
int main()
{
    int n;
    printf("Enter a number: ");
    scanf("%d", &n);
    printf("Factorial of %d is %d\n", n, fact(n));
    return 0;
}

int fact(int n)
{
    if(n == 0 || n == 1)
        return 1;
    else
        return n * fact(n - 1);
}
      </code></pre> <br>
      <strong>Output:</strong> <br>
      <img src="./img/chp4/Function/factorial_recur_fn.png" alt="unavailable">

            <p><strong>Example 2: Sum of natural numbers</strong></p>
      <pre><code>
#include &lt;stdio.h&gt;
int sum(int);
int main()
{
    int n;
    printf("Enter a number: ");
    scanf("%d", &n);
    printf("Sum of first %d natural numbers is %d\n", n, sum(n));
    return 0;
}

int sum(int n)
{
    if(n == 0)
        return 0;
    else
        return n + sum(n - 1);
}
      </code></pre> <br>
      <strong>Output:</strong> <br>
      <img src="./img/chp4/Function/noSUM_recur_fn.png" alt="unavailable">
    </div>

    <div class="section">
      <h2>5. Passing Array to a Function</h2>
      <p><strong>Example: Sum of Array Elements</strong></p>
      <pre><code>
#include &lt;stdio.h&gt;
void addarray(int[], int);
int main() 
{
    int n;
    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);
    
    int arr[n];
    printf("Enter %d elements:\n", n);
    for(int i = 0; i < n; i++) 
    {
        scanf("%d", &arr[i]);
    }
    addarray(arr, n); 
    return 0;
}

void addarray(int arr[], int size) 
{
    int sum = 0;
    for(int i = 0; i < size; i++) 
    {
        sum += arr[i];
    }
    printf("Sum of the array elements is: %d\n", sum);
}
      </code></pre> <br>
      <strong>Output: </strong> <br>
      <img src="./img/chp4/Function/array_fn.png" alt="unavailable">
    </div>
  </div>

  <div class="section">
    <h2>Structure and Union</h2>
    <div class="section">
      <h2>Introduction to Structure</h2>
      <p>A struct (short for structure) in C is a user-defined data type that groups together different variables (possibly of different types) under one name. It is used to represent a record or a collection of related data.</p>
      <h3>Syntax:</h3>
      <pre><code>
struct StructName {
    dataType member1;
    dataType member2;
    ...
    dataType memberN;
};
      </code></pre>
      <h3>Size Determination:</h3>
      <p>The total size of the struct is determined by the variables used in the struct. Specifically, it is the sum of the bytes that each of the variables would store.</p>
      <pre>
        <code>
struct Example {
    char c;     // 1 byte
    int i;      // 4 bytes
};
        </code>
      </pre>
      <p>In this example, the total storage size of struct is 1 + 4 = 5 bytes. (Note: the compiler generally stores some extra padding space, which can be neglected as its usually ~3-4 bytes)</p>
    </div>

    <div class="section">
      <h2>Using and accessing struct</h2>
      <h3>Example 1:</h3>
      <pre><code>
#include &lt;stdio.h&gt;
// Defining a struct
struct Student {
    int id;
    char name[20];
    float marks;
};
int main() {
    struct Student s1 = {101, "Harshit", 89.5}; // Initializing a struct
    printf("Student ID: %d\n", s1.id);
    printf("Student Name: %s\n", s1.name);
    printf("Student Marks: %.2f\n", s1.marks);
    printf("\nProgram Executed by Harshit Karna");
    return 0;
}
      </code></pre>
      <h3>Output:</h3>
      <img src="./img/chp4/Struct & Union/Struct_demo.png" alt="unavailable">
    </div>
    <div class="section">
      <h2>Nested struct</h2>
      <h3>Example 1:</h3>
      <pre><code>
#include &lt;stdio.h&gt;
// Defining nested structs
struct Address {
    char city[20];
    int pin;
};
struct Student {
    int id;
    char name[20];
    struct Address addr;  // Nested struct
};
int main() {
    // Creating a struct variable
    struct Student s1 = {101, "Harshit", {"Kathmandu", 44600}};
    printf("Student ID: %d\n", s1.id);
    printf("Student Name: %s\n", s1.name);
    printf("City: %s\n", s1.addr.city);
    printf("PIN Code: %d\n", s1.addr.pin);
    printf("\nProgram Executed by Harshit Karna");
    return 0;
}
      </code></pre>
      <h3>Output:</h3>
      <img src="./img/chp4/Struct & Union/Struct_Nested.png" alt="unavailable">
    </div>
    <div class="section">
      <h2>Array of Struct</h2>
      <h3>Example 1: C program that inputs id, name and price of N
number of books using Structure and print them.</h3>
<pre><code>
  #include &lt;stdio.h&gt;
struct books {
  int bookid;
  char bookname[50];
  unsigned int price;
};
void strdsply(struct books book[], int n) {
  int i;
  printf("The data stored is:\n\n");
  printf("Book ID\tBook Name\tPrice\n");
  for (i = 0; i < n; i++) {
    printf("%d\t%s\t\t%u\n", book[i].bookid, book[i].bookname, book[i].price);
  }
}
int main() {
  int n = 0, i;
  typedef struct books stbk;
  printf("How many books to enter? ");
  scanf("%d", &n);
  stbk book[n];
  for (i = 0; i < n; i++) {
    printf("Enter book id: ");
    scanf("%d", &book[i].bookid);
    printf("Enter book name: ");
    scanf("%s", book[i].bookname);
    printf("Enter its price: ");
    scanf("%d", &book[i].price);
  }
  strdsply(book, n);
  printf("\nProgram Executed by Harshit Karna\n");
  return 0;
}
</code></pre>
      <h3>Output:</h3>
      <img src="./img/chp4/Struct & Union/Struct+Array.png" alt="unavailable">
    </div>
    <div class="section">
      <h2>Passing Struct to Function</h2>
      <h3>Example: C program that inputs name and address of 5
students using Structure and arrange them alphabetically by
the name of the student.</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
struct student {
  char name[50];
  char address[100];
};
void inptStd(struct student s[], int n) {
  int i;
  for (i = 0; i < n; i++) {
    printf("Enter name of student %d: ", i + 1);
    scanf("%s", s[i].name);
    printf("Enter address of student %d: ", i + 1);
    scanf(" %s", s[i].address);
  }
}
void sortStd(struct student s[], int n) {
  struct student temp;
  int i, j;
  for (i = 0; i < n - 1; i++) {
    for (j = i + 1; j < n; j++) {
      if (strcmp(s[i].name, s[j].name) > 0) {
        temp = s[i];
        s[i] = s[j];
        s[j] = temp;
      }
    }
  }
}
void dsplyStd(struct student s[], int n) {
  printf("\nStudents sorted by name:\n");
  printf("Name\t\tAddress\n");
  int i;
  for (i = 0; i < n; i++) {
    printf("%s\t\t%s\n", s[i].name, s[i].address);
  }
}
int main() {
  struct student students[5];
  inptStd(students, 5);
  sortStd(students, 5);
  dsplyStd(students, 5);
  printf("\nProgram Executed by Harshit Karna");
  return 0;
}
</code></pre>
      <h3>Output:</h3>
      <img src="./img/chp4/Struct & Union/Struct+Func.png" alt="unavailable">
    </div>

    <div class="section">
      <h2>Union</h2>
      <h3>Introduction:</h3>
      <p>A union in C is a special data type that allows you to store different data types in the same memory location. Unlike a struct, where each member gets its own memory location, all members of a union share the same memory space. The size of a union is determined by the size of its largest member.</p>
      <h3>Syntax:</h3>
      <pre><code>
union UnionName {
    dataType member1;
    dataType member2;
    ...
    dataType memberN;
};
      </code></pre>
    </div>

    <div class="section">
      <h2>Comparison Between Struct & Union</h2>
      <div class="tble-container">
      <table class="tble">
        <thead>
          <tr>
            <th>Aspect</th>
            <th>Struct</th>
            <th>Union</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Memory Allocation</td>
            <td>Each member has its own memory; total size is sum of all members (plus padding).</td>
            <td>All members share the same memory; size is equal to the largest member.</td>
          </tr>
          <tr>
            <td>Storage</td>
            <td>Can store values of all members simultaneously.</td>
            <td>Can store value of only one member at a time.</td>
          </tr>
          <tr>
            <td>Usage</td>
            <td>Used when data of different types must be stored together and accessed independently.</td>
            <td>Used when only one member is needed at a time, to save memory.</td>
          </tr>
          <tr>
            <td>Access</td>
            <td>All members can be accessed without affecting others.</td>
            <td>Changing one member changes the shared memory, affecting others.</td>
          </tr>
          <tr>
            <td>Size</td>
            <td>Larger, since it is the sum of all member sizes.</td>
            <td>Smaller, since it is equal to the largest member size.</td>
          </tr>
        </tbody>
      </table>
    </div>
    </div>
  </div>
<div class="section">
  <h2>Pointers</h2>

  <div class="section">
    <h2>Introduction and Syntax</h2>
    <p>
      A pointer is a variable that stores the <strong>address</strong> of another variable. Pointers enable
      indirect access to memory, efficient parameter passing, dynamic memory management, and working with arrays/strings.
    </p>
    <h3>General Syntax</h3>
    <pre><code>
data_type *ptr;   // ptr is a pointer to data_type
ptr = &amp;variable;  // store the address of variable into ptr
*ptr               // dereference: access the value stored at that address
    </code></pre>
  </div>

  <div class="section">
    <h2>Usage and Working</h2>
    <ul>
      <li><strong>Address-of (&amp;):</strong> obtains the memory address of a variable.</li>
      <li><strong>Dereference (*):</strong> accesses/updates the value at the address stored in a pointer.</li>
      <li><strong>Null pointers:</strong> initialized to <code>NULL</code> (or <code>0</code>) to indicate “points to nothing.”</li>
      <li><strong>Pointer arithmetic:</strong> adding/subtracting integers moves by element size (e.g., <code>int*</code> steps by <code>sizeof(int)</code>).</li>
    </ul>
  </div>

  <div class="section">
    <h2>Concept of Value and Address</h2>
    <p>
      Every variable has two aspects: its <strong>value</strong> (the data it holds) and its <strong>address</strong> (where it lives in memory).
      Pointers store addresses and let us read or modify the value indirectly through dereferencing.
    </p>
    <table class="tble">
      <thead>
        <tr>
          <th>Term</th>
          <th>Meaning</th>
          <th>Operator / Example</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Value</td>
          <td>Actual data stored in a variable</td>
          <td><code>x</code></td>
        </tr>
        <tr>
          <td>Address</td>
          <td>Memory location of that variable</td>
          <td><code>&amp;x</code></td>
        </tr>
        <tr>
          <td>Pointer</td>
          <td>Variable that stores an address</td>
          <td><code>int *p = &amp;x;</code></td>
        </tr>
        <tr>
          <td>Dereference</td>
          <td>Access value at stored address</td>
          <td><code>*p</code> gives value of <code>x</code></td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>Declaration and Initialization</h2>
    <pre><code>
int x = 10;
int *p = &amp;x;     // initialized to address of x
int *q = NULL;   // safe "points to nothing" until assigned
    </code></pre>
  </div>

  <div class="section">
    <h2>Pointer and Function</h2>
    <p><strong>Idea:</strong> Pass addresses to functions so users can access/modify caller data efficiently.</p>
    <pre><code>
#include &lt;stdio.h&gt;
void square(int *n) {
    *n = (*n) * (*n);
}
int main() {
    int num = 5;
    printf("Original number: %d\n", num);
    square(&num); // pass address to function
    printf("Squared number: %d\n", num);
    printf("\nProgram Executed by Harshit Karna");
    return 0;
}
    </code></pre>
    <h3>Output:</h3>
    <img src="./img/chp4/Pointer/Pointer+Func.png" alt="unavailable">
  </div>

  <div class="section">
    <h2>Call by Reference</h2>
    <p><strong>Idea:</strong> Simulate call-by-reference in C by passing addresses (pointers) of variables to functions.</p>
    <pre><code>
#include &lt;stdio.h&gt;
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
int main() {
    int x = 10, y = 20;
    printf("Before swap: x = %d, y = %d\n", x, y);
    swap(&x, &y); // pass addresses for call by reference
    printf("After swap: x = %d, y = %d\n", x, y);
    printf("\nProgram Executed by Harshit Karna");
    return 0;
}
    </code></pre>
    <h3>Output:</h3>
    <img src="./img/chp4/Pointer/Pointer_ClByRef.png" alt="unavailable">
  </div>

  <div class="section">
    <h2>Comparison between Call by Value and Call by Reference</h2>
    <table class="tble">
      <thead>
        <tr>
          <th>Aspect</th>
          <th>Call by Value</th>
          <th>Call by Reference (via pointers)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>What is passed</td>
          <td>A copy of the value</td>
          <td>Address of the original variable</td>
        </tr>
        <tr>
          <td>Effect on caller data</td>
          <td>No change to original</td>
          <td>Function can modify original</td>
        </tr>
        <tr>
          <td>Memory/Speed</td>
          <td>Extra copying for large data</td>
          <td>Efficient for large data (no copy)</td>
        </tr>
        <tr>
          <td>Safety</td>
          <td>Safer (isolation)</td>
          <td>Requires careful handling of pointers</td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>Pointer with Arrays</h2>
    <p><strong>Key facts:</strong> Array name often acts like a pointer to its first element; <code>a[i]</code> equals <code>*(a + i)</code>.</p>
    <pre><code>
#include &lt;stdio.h&gt;
int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int *p = arr; // array name acts as pointer to first element
    printf("Array elements using pointer:\n");
    for (int i = 0; i < 5; i++) {
        printf("%d ", *(p + i));
    }
    printf("\nProgram Executed by Harshit Karna");
    return 0;
}
    </code></pre>
    <h3>Output:</h3>
    <img src="./img/chp4/Pointer/Pointer+Array.png" alt="unavailable">
  </div>

  <div class="section">
    <h2>Advantages and Disadvantages</h2>
    <table class="tble">
      <thead>
        <tr>
          <th>Advantages</th>
          <th>Disadvantages</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Efficient parameter passing for large data</td>
          <td>Dangling/NULL pointer dereference can crash</td>
        </tr>
        <tr>
          <td>Enables dynamic memory management</td>
          <td>Pointer arithmetic errors are subtle</td>
        </tr>
        <tr>
          <td>Supports complex data structures (lists, trees)</td>
          <td>Harder to read/maintain if misused</td>
        </tr>
        <tr>
          <td>Direct memory access when needed</td>
          <td>Security risks if not validated</td>
        </tr>
      </tbody>
    </table>
  </div>
</div>

<div class="section">
  <h2>File Handling in C</h2>

  <div class="section">
    <h2>Concept of Data File</h2>
    <p>
      A data file stores information on secondary storage (disk) in a persistent form so that programs can
      read/write it across multiple executions.
    </p>
  </div>

  <div class="section">
    <h2>Need for File Handling in C</h2>
    <ul>
      <li>Persist data beyond program termination.</li>
      <li>Handle large datasets that do not fit in memory.</li>
      <li>Exchange data between programs and sessions.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Sequential and Random Files</h2>
    <table class="tble">
      <thead>
        <tr>
          <th>Type</th>
          <th>Access Pattern</th>
          <th>Use Case</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Sequential File</td>
          <td>Read/write in order from start to end</td>
          <td>Logs, reports, line-by-line processing</td>
        </tr>
        <tr>
          <td>Random (Direct) File</td>
          <td>Jump to any location (seek by offset)</td>
          <td>Databases, indexed records, partial updates</td>
        </tr>
      </tbody>
    </table>
    <img src="./img/chp4/File Handling/Sequential&Random_Access.jpg" alt="unavailable">
  </div>

  <div class="section">
    <h2>File Handling Functions (Purpose &amp; Syntax)</h2>
    <table class="tble">
      <thead>
        <tr>
          <th>Function</th>
          <th>Purpose</th>
          <th>Syntax</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>fopen()</code></td>
          <td>Open a file and return a <code>FILE*</code> stream</td>
          <td><code>FILE *fp = fopen("name","mode");</code></td>
        </tr>
        <tr>
          <td><code>fclose()</code></td>
          <td>Close an open file stream</td>
          <td><code>int r = fclose(fp);</code></td>
        </tr>
        <tr>
          <td><code>getc()</code>, <code>putc()</code></td>
          <td>Character I/O on files</td>
          <td><code>int ch = getc(fp);</code> &nbsp; <code>int r = putc(ch, fp);</code></td>
        </tr>
        <tr>
          <td><code>fprintf()</code>, <code>fscanf()</code></td>
          <td>Formatted text I/O</td>
          <td><code>fprintf(fp, "fmt", ...);</code> &nbsp; <code>fscanf(fp, "fmt", &amp;...);</code></td>
        </tr>
        <tr>
          <td><code>getw()</code>, <code>putw()</code></td>
          <td>Integer I/O (non-standard/obsolete on many systems)</td>
          <td><code>int n = getw(fp);</code> &nbsp; <code>putw(n, fp);</code></td>
        </tr>
        <tr>
          <td><code>fgets()</code>, <code>fputs()</code></td>
          <td>Line/string I/O</td>
          <td><code>char *s = fgets(buf, size, fp);</code> &nbsp; <code>fputs(s, fp);</code></td>
        </tr>
        <tr>
          <td><code>fread()</code>, <code>fwrite()</code></td>
          <td>Binary block I/O</td>
          <td><code>size_t n = fread(ptr, sz, cnt, fp);</code> &nbsp; <code>fwrite(ptr, sz, cnt, fp);</code></td>
        </tr>
        <tr>
          <td><code>remove()</code>, <code>rename()</code></td>
          <td>Delete or rename a file</td>
          <td><code>int r = remove("old.txt");</code> &nbsp; <code>int r2 = rename("old","new");</code></td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>Random Access Functions (Purpose &amp; Syntax)</h2>
    <table class="tble">
      <thead>
        <tr>
          <th>Function</th>
          <th>Purpose</th>
          <th>Syntax</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>fseek()</code></td>
          <td>Move file position indicator to offset</td>
          <td><code>int r = fseek(fp, offset, origin);</code></td>
        </tr>
        <tr>
          <td><code>rewind()</code></td>
          <td>Set position to beginning (like <code>fseek(fp,0,SEEK_SET)</code>)</td>
          <td><code>rewind(fp);</code></td>
        </tr>
        <tr>
          <td><code>ftell()</code></td>
          <td>Get current file position</td>
          <td><code>long pos = ftell(fp);</code></td>
        </tr>
      </tbody>
    </table>
  </div>

  <div class="section">
    <h2>File Opening Modes</h2>
    <table class="tble">
      <thead>
        <tr>
          <th>Mode</th>
          <th>Meaning</th>
          <th>Must Exist?</th>
          <th>Pointer Position</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>r</code></td>
          <td>Read (text)</td>
          <td>Yes</td>
          <td>Start</td>
        </tr>
        <tr>
          <td><code>r+</code></td>
          <td>Read/Write (text)</td>
          <td>Yes</td>
          <td>Start</td>
        </tr>
        <tr>
          <td><code>w</code></td>
          <td>Write (truncate/create, text)</td>
          <td>No</td>
          <td>Start</td>
        </tr>
        <tr>
          <td><code>w+</code></td>
          <td>Read/Write (truncate/create, text)</td>
          <td>No</td>
          <td>Start</td>
        </tr>
        <tr>
          <td><code>a</code></td>
          <td>Append (text)</td>
          <td>No</td>
          <td>End</td>
        </tr>
        <tr>
          <td><code>a+</code></td>
          <td>Read/Append (text)</td>
          <td>No</td>
          <td>End (reads from start, writes at end)</td>
        </tr>
      </tbody>
    </table>
    <p><em>Binary variants:</em> add <code>b</code> (e.g., <code>"rb"</code>, <code>"wb"</code>, <code>"ab"</code>).</p>
  </div>

  <div class="section">
    <h2>Steps to Work with File in C</h2>
    <ol>
      <li><strong>Define File Pointer</strong> &mdash; e.g., <code>FILE *fp;</code></li>
      <li><strong>Open File with Required Mode</strong> &mdash; <code>fp = fopen("data.txt","r");</code></li>
      <li><strong>Read, Write, Append Operations</strong> &mdash; use appropriate functions.</li>
      <li><strong>Close the File</strong> &mdash; <code>fclose(fp);</code></li>
    </ol>
  </div>

  <div class="section">
    <h2>Writing Data on Files</h2>
    <pre><code>
#include &lt;stdio.h&gt;
int main() {
    FILE *fp;
    fp = fopen("901.txt", "w");  // open file in write mode
    fprintf(fp, "Hello, this is a test file.\n");
    fclose(fp);
    printf("Data written successfully.\n");
    printf("\nProgram Executed by Harshit Karna");
    return 0;
}
    </code></pre>
    <h3>Output:</h3>
    <img src="./img/chp4/File Handling/Simple_Writing(O).png" alt="unavailable">
    <img src="./img/chp4/File Handling/Simple_Writing(F).png" alt="unavailable">
  </div>

  <div class="section">
    <h2>Reading Data from Files</h2>
    <pre><code>
#include &lt;stdio.h&gt;
int main() {
    FILE *fp;
    char ch;
    fp = fopen("901.txt", "r");  // open file in read mode
    printf("Contents of 901.txt:\n");
    while ((ch = getc(fp)) != EOF) {
        putchar(ch);
    }
    fclose(fp);
    printf("\nProgram Executed by Harshit Karna");
    return 0;
}
    </code></pre>
    <h3>Output:</h3>
    <img src="./img/chp4/File Handling/Simple_Reading(O).png" alt="unavailable">
  </div>

  <div class="section">
    <h2>Appending Data Files</h2>
    <pre><code>
#include <stdio.h>
int main() {
    FILE *fp;
    fp = fopen("901.txt", "a");  // open file in append mode
    fprintf(fp, "I can keep adding new info using append.\n");
    fclose(fp);
    printf("Data appended successfully.\n");
    printf("\nProgram Executed by Harshit Karna");
    return 0;
}
    </code></pre>
    <h3>Output:</h3>
    <img src="./img/chp4/File Handling/Simple_Appending(O).png" alt="unavailable">
    <img src="./img/chp4/File Handling/Simple_Appending(F).png" alt="unavailable">
  </div>

  <div class="section">
    <h2>End of File (EOF)</h2>
    <p>
      <code>EOF</code> signals that no more data can be read from a file stream. Many I/O functions return
      <code>EOF</code> (commonly <code>-1</code>) or <code>NULL</code> to indicate end-of-file or error.
    </p>
  </div>

  <div class="section">
    <h2><code>typedef</code> Keyword in C</h2>
    <p>
      <code>typedef</code> creates an alias (alternate name) for existing types, improving readability and portability.
    </p>
    <h3>Syntax</h3>
    <pre><code>
typedef existing_type NewName;   // e.g., typedef unsigned long ulong;
    </code></pre>
  </div>
</div>


    <div class="section" id="questions">
      <h1>Questions and Answers</h1>
      <hr>

      <h2>COMING SOON</h2>
<!--
      <h2>1. What is data in the context of a DBMS?</h2>
      <p>Data refers to raw, unprocessed facts and figures such as numbers, names, or dates. In a DBMS, data is stored in structured formats to be organized and made meaningful through processing.</p>
    </div>

    <div class="section">
      <h2>2. How does information differ from data?</h2>
      <p>Information is processed data that has been structured and given context to be useful. Unlike raw data, information helps in decision-making and provides meaningful insights.</p>
    </div>

    <div class="section">
      <h2>3. What is a database?</h2>
      <p>A database is an organized collection of related data stored electronically. It allows for efficient storage, retrieval, and management of data using database software.</p>
    </div>

    <div class="section">
      <h2>4. What are the main features of a DBMS?</h2>
      <ul>
        <li>Ensures data integrity and consistency</li>
        <li>Provides security against unauthorized access</li>
        <li>Supports backup and recovery</li>
        <li>Allows concurrent data access</li>
        <li>Maintains data independence</li>
      </ul>
    </div>

    <div class="section">
      <h2>5. List two advantages and two disadvantages of using a DBMS.</h2>
      <p><strong>Advantages:</strong></p>
      <ul>
        <li>Centralized data management</li>
        <li>Reduced data redundancy</li>
      </ul>
      <p><strong>Disadvantages:</strong></p>
      <ul>
        <li>High initial setup cost</li>
        <li>Requires regular maintenance and skilled personnel</li>
      </ul>
    </div>

    <div class="section">
      <h2>6. What is a relational database model?</h2>
      <p>The relational model organizes data into tables, where each table consists of rows (records) and columns (fields). It is widely used due to its simplicity, flexibility, and support for SQL-based queries.</p>
    </div>

    <div class="section">
      <h2>7. Define primary key and foreign key.</h2>
      <p><strong>Primary Key:</strong> A field (or combination of fields) that uniquely identifies each record in a table.</p>
      <p><strong>Foreign Key:</strong> A field in one table that refers to the primary key of another table, establishing a relationship between the two tables.</p>
    </div>

    <div class="section">
      <h2>8. What is normalization? List its first three normal forms.</h2>
      <p>Normalization is a design process used to organize data in a database to minimize redundancy and improve integrity. The first three normal forms are:</p>
      <ul>
        <li><strong>1NF:</strong> Eliminates repeating groups and ensures atomicity.</li>
        <li><strong>2NF:</strong> Removes partial dependencies on composite primary keys.</li>
        <li><strong>3NF:</strong> Eliminates transitive dependencies between non-key attributes.</li>
      </ul>
    </div>

    <div class="section">
      <h2>9. What is the difference between centralized and distributed databases?</h2>
      <p><strong>Centralized Database:</strong> Stored at a single location, easier to manage, but vulnerable to single-point failures.</p>
      <p><strong>Distributed Database:</strong> Spread across multiple locations, more reliable and scalable, but harder to manage and maintain.</p>
    </div>

    <div class="section">
      <h2>10. What are domain, entity integrity, and referential integrity constraints?</h2>
      <ul>
        <li><strong>Domain Constraint:</strong> Ensures values fall within a valid range or type.</li>
        <li><strong>Entity Integrity:</strong> Requires primary keys to be unique and not null.</li>
        <li><strong>Referential Integrity:</strong> Ensures foreign keys correctly reference existing records.</li>
      </ul>
    </div>
    -->

  </div>

    <div class="section" id="neb-ques">
    <h1>Past NEB Questions</h1>
    <hr>
    <h2>COMING SOON</h2>

    <!--

    <div class="section">
      <h2>1. What is Database and DBMS? List out the advantages and disadvantages of DBMS.</h2>
      <p><strong>Database:</strong> An organized collection of related data stored electronically in a structured way.</p>
      <p><strong>DBMS:</strong> A software system that allows users to define, create, maintain, and control access to the database.</p>
      <p><strong>Advantages:</strong></p>
      <ul>
        <li>Reduced data redundancy</li>
        <li>Improved data integrity and consistency</li>
        <li>Better data security</li>
        <li>Supports concurrent access</li>
        <li>Provides backup and recovery</li>
      </ul>
      <p><strong>Disadvantages:</strong></p>
      <ul>
        <li>High initial setup cost</li>
        <li>Complex to manage</li>
        <li>Requires skilled personnel</li>
        <li>Performance may be affected with large data volume</li>
      </ul>
    </div>

    <div class="section">
      <h2>2. Differentiate between file processing system and DBMS. Give at least four points.</h2>
      <table class="tble">
        <thead>
          <tr>
            <th>File Processing System</th>
            <th>DBMS</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Data redundancy is high</td>
            <td>Data redundancy is minimized</td>
          </tr>
          <tr>
            <td>No centralized control over data</td>
            <td>Centralized control of data</td>
          </tr>
          <tr>
            <td>Limited security features</td>
            <td>Advanced security and access control</td>
          </tr>
          <tr>
            <td>Difficult to handle concurrent access</td>
            <td>Supports concurrent multi-user access</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="section">
      <h2>3. Explain the different models of DBMS with advantages and disadvantages.</h2>
      <p><strong>Hierarchical Model:</strong> Organizes data in a tree structure with parent-child relationships.</p>
      <p><strong>Advantages:</strong> Fast access to hierarchical data, simple relationships.</p>
      <p><strong>Disadvantages:</strong> Inflexible structure, difficult to handle many-to-many relationships.</p>
      <p><strong>Network Model:</strong> Uses a graph structure with multiple parent-child relationships.</p>
      <p><strong>Advantages:</strong> Supports complex relationships, efficient for many-to-many connections.</p>
      <p><strong>Disadvantages:</strong> More complex to design and maintain.</p>
      <p><strong>Relational Model:</strong> Stores data in tables with rows and columns.</p>
      <p><strong>Advantages:</strong> Easy to understand, flexible, uses SQL.</p>
      <p><strong>Disadvantages:</strong> Can be slower with very large datasets due to joins.</p>
    </div>

    <div class="section">
      <h2>4. What is a relational database? How is it different from other database models?</h2>
      <p>A relational database organizes data into tables (relations) where each record is a row and each attribute is a column. It differs from hierarchical and network models by using simple tabular structures and supporting SQL for flexible querying. Relationships are managed through keys rather than pointers.</p>
    </div>

    <div class="section">
      <h2>5. What is data redundancy? How does DBMS help in reducing it?</h2>
      <p>Data redundancy is unnecessary duplication of data across files or tables. DBMS reduces redundancy by storing data centrally and normalizing it, so each data item is recorded only once and shared as needed.</p>
    </div>

    <div class="section">
      <h2>6. Write differentiate between centralized and distributed database systems.</h2>
      <table class="tble">
        <thead>
          <tr>
            <th>Centralized Database</th>
            <th>Distributed Database</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Stored in a single location</td>
            <td>Distributed across multiple locations</td>
          </tr>
          <tr>
            <td>Easy to manage and secure</td>
            <td>More complex management and security</td>
          </tr>
          <tr>
            <td>Single point of failure</td>
            <td>Higher reliability with redundancy</td>
          </tr>
          <tr>
            <td>May have performance bottlenecks</td>
            <td>Improved performance through distribution</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="section">
      <h2>7. Who is Database Administrator (DBA)? What are the major responsibilities of DBA?</h2>
      <p>A Database Administrator (DBA) is a person responsible for managing, maintaining, and securing the database system.</p>
      <p><strong>Major Responsibilities:</strong></p>
      <ul>
        <li>Defining user access permissions</li>
        <li>Monitoring and optimizing database performance</li>
        <li>Ensuring data security and integrity</li>
        <li>Backup and recovery management</li>
        <li>Installing and upgrading DBMS software</li>
      </ul>
    </div>

    <div class="section">
      <h2>8. Define normalization. Explain 1NF, 2NF and 3NF with suitable examples. Explain the normalization process with examples.</h2>
      <p><strong>Normalization:</strong> The process of organizing data to reduce redundancy and improve integrity.</p>
      <p><strong>1NF:</strong> All attributes have atomic values. For example, splitting a "Phone Numbers" field containing multiple numbers into separate rows.</p>
      <p><strong>2NF:</strong> No partial dependency on a part of the composite key. For example, separating student and course information if course details depend only on course ID.</p>
      <p><strong>3NF:</strong> No transitive dependency between non-key attributes. For example, removing a "Department Name" field from an employee table if it's dependent on Department ID, which is already a key.</p>
    </div>

    <div class="section">
      <h2>9. Explain the terms: primary key, foreign key, and candidate key with examples.</h2>
      <p><strong>Primary Key:</strong> A unique identifier for a record. Example: StudentID in a student table.</p>
      <p><strong>Foreign Key:</strong> A field linking to a primary key in another table. Example: DepartmentID in Employee table referencing Department table.</p>
      <p><strong>Candidate Key:</strong> Any field or combination of fields that can uniquely identify a record. Example: Email or NationalID could be candidate keys.</p>
    </div>

    <div class="section">
      <h2>10. What is SQL? Explain its components and common functions.</h2>
      <p><strong>SQL (Structured Query Language):</strong> A language used to manage and query relational databases.</p>
      <p><strong>Components:</strong></p>
      <ul>
        <li><strong>DDL (Data Definition Language):</strong> CREATE, ALTER, DROP</li>
        <li><strong>DML (Data Manipulation Language):</strong> SELECT, INSERT, UPDATE, DELETE</li>
        <li><strong>DCL (Data Control Language):</strong> GRANT, REVOKE</li>
        <li><strong>TCL (Transaction Control Language):</strong> COMMIT, ROLLBACK</li>
      </ul>
      <p><strong>Common Functions:</strong></p>
      <ul>
        <li>Querying data using SELECT</li>
        <li>Inserting data with INSERT</li>
        <li>Updating records with UPDATE</li>
        <li>Deleting records using DELETE</li>
        <li>Defining schema with CREATE</li>
      </ul>
    </div>
    -->
  </div>

    
  <a href="#top" id="scrollTopBtn">↑</a>
</body>

</html>

